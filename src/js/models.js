import stone_isolatedSrc from "../images/Stone/newStone/stone_isolated.png";
import stone_connectedLeftSrc from "../images/Stone/newStone/stone_connectedLeft.png";
import stone_connectedRightSrc from "../images/Stone/newStone/stone_connectedRight.png";
import stone_connectedTopSrc from "../images/Stone/newStone/stone_connectedTop.png";
import stone_connectedBottomSrc from "../images/Stone/newStone/stone_connectedBottom.png";
import stone_betweenHorizontalSrc from "../images/Stone/newStone/stone_betweenHorizontal.png";
import stone_betweenVerticalSrc from "../images/Stone/newStone/stone_betweenVertical.png";
import stone_connectedBottomAndRightSrc from "../images/Stone/newStone/stone_connectedBottomAndRight.png";
import stone_connectedBottomAndLeftSrc from "../images/Stone/newStone/stone_connectedBottomAndLeft.png";
import stone_connectedTopAndLeftSrc from "../images/Stone/newStone/stone_connectedTopAndLeft.png";
import stone_connectedTopAndRightSrc from "../images/Stone/newStone/stone_connectedTopAndRight.png";
import stone_connectedAllSrc from "../images/Stone/newStone/stone_connectedAll.png";
import stone_betweenVertical_connectedLeftSrc from "../images/Stone/newStone/stone_betweenVertical_connectedLeft.png";
import stone_betweenVertical_connectedRightSrc from "../images/Stone/newStone/stone_betweenVertical_connectedRight.png";
import stone_betweenHorizontal_connectedTopSrc from "../images/Stone/newStone/stone_betweenHorizontal_connectedTop.png"
import stone_betweenHorizontal_connectedBottomSrc from "../images/Stone/newStone/stone_betweenHorizontal_connectedBottom.png"

import cellSrc from  "../images/cell.png";

import player1Src1right from "../images/players/player1/player1_anim1_right.png";
import player1Src2right from "../images/players/player1/player1_anim2_right.png";
import player1Src3right from "../images/players/player1/player1_anim3_right.png";
import player1Src4right from "../images/players/player1/player1_anim4_right.png";
import player1Src5right from "../images/players/player1/player1_anim5_right.png";
import player1Src6right from "../images/players/player1/player1_anim6_right.png";
import player1Src1left from "../images/players/player1/player1_anim1_left.png";
import player1Src2left from "../images/players/player1/player1_anim2_left.png";
import player1Src3left from "../images/players/player1/player1_anim3_left.png";
import player1Src4left from "../images/players/player1/player1_anim4_left.png";
import player1Src5left from "../images/players/player1/player1_anim5_left.png";
import player1Src6left from "../images/players/player1/player1_anim6_left.png";
import player1SrcStopLeft from "../images/players/player1/player1_stop_left.png";
import player1SrcStopRight from "../images/players/player1/player1_stop_right.png";

import coinSrc1 from "../images/loot/coins/coin1.png";
import coinSrc2 from "../images/loot/coins/coin2.png";
import coinSrc3 from "../images/loot/coins/coin3.png";
import coinSrc4 from "../images/loot/coins/coin4.png";
import coinSrc5 from "../images/loot/coins/coin5.png";
import coinSrc6 from "../images/loot/coins/coin6.png";

import trapSrc1 from "../images/trap/trap1.png";
import trapSrc2 from "../images/trap/trap2.png";
import trapSrc3 from "../images/trap/trap3.png";
import trapSrc4 from "../images/trap/trap4.png";

import soundCoinSrc from "../sounds/coin2.mp3";

const stone_isolatedImg = new Image();
stone_isolatedImg.src = stone_isolatedSrc;
const stone_connectedLeftImg = new Image();
stone_connectedLeftImg.src = stone_connectedLeftSrc;
const stone_connectedRightImg = new Image();
stone_connectedRightImg.src = stone_connectedRightSrc;
const stone_connectedTopImg = new Image();
stone_connectedTopImg.src = stone_connectedTopSrc;
const stone_connectedBottomImg = new Image();
stone_connectedBottomImg.src = stone_connectedBottomSrc;
const stone_betweenHorizontalImg = new Image();
stone_betweenHorizontalImg.src = stone_betweenHorizontalSrc;
const stone_betweenVerticalImg = new Image();
stone_betweenVerticalImg.src = stone_betweenVerticalSrc;
const stone_connectedBottomAndRightImg = new Image();
stone_connectedBottomAndRightImg.src = stone_connectedBottomAndRightSrc;
const stone_connectedBottomAndLeftImg = new Image();
stone_connectedBottomAndLeftImg.src = stone_connectedBottomAndLeftSrc;
const stone_connectedTopAndLeftImg = new Image();
stone_connectedTopAndLeftImg.src = stone_connectedTopAndLeftSrc;
const stone_connectedTopAndRightImg = new Image();
stone_connectedTopAndRightImg.src = stone_connectedTopAndRightSrc;
const stone_connectedAllImg = new Image();
stone_connectedAllImg.src = stone_connectedAllSrc;
const stone_betweenVertical_connectedLeftImg = new Image();
stone_betweenVertical_connectedLeftImg.src = stone_betweenVertical_connectedLeftSrc;
const stone_betweenVertical_connectedRightImg = new Image();
stone_betweenVertical_connectedRightImg.src = stone_betweenVertical_connectedRightSrc;
const stone_betweenHorizontal_connectedTopImg = new Image();
stone_betweenHorizontal_connectedTopImg.src = stone_betweenHorizontal_connectedTopSrc;
const stone_betweenHorizontal_connectedBottomImg = new Image();
stone_betweenHorizontal_connectedBottomImg.src = stone_betweenHorizontal_connectedBottomSrc;

const cellImg = new Image();
cellImg.src = cellSrc;

const player1Img1right = new Image();
player1Img1right.src = player1Src1right;
const player1Img2right = new Image();
player1Img2right.src = player1Src2right;
const player1Img3right = new Image();
player1Img3right.src = player1Src3right;
const player1Img4right = new Image();
player1Img4right.src = player1Src4right;
const player1Img5right = new Image();
player1Img5right.src = player1Src5right;
const player1Img6right = new Image();
player1Img6right.src = player1Src6right;

const player1Img1left = new Image();
player1Img1left.src = player1Src1left;
const player1Img2left = new Image();
player1Img2left.src = player1Src2left;
const player1Img3left = new Image();
player1Img3left.src = player1Src3left;
const player1Img4left = new Image();
player1Img4left.src = player1Src4left;
const player1Img5left = new Image();
player1Img5left.src = player1Src5left;
const player1Img6left = new Image();
player1Img6left.src = player1Src6left;

const player1ImgStopLeft = new Image();
player1ImgStopLeft.src = player1SrcStopLeft;
const player1ImgStopRight = new Image();
player1ImgStopRight.src = player1SrcStopRight;

const coinImg1 = new Image();
coinImg1.src = coinSrc1;
const coinImg2 = new Image();
coinImg2.src = coinSrc2;
const coinImg3 = new Image();
coinImg3.src = coinSrc3;
const coinImg4 = new Image();
coinImg4.src = coinSrc4;
const coinImg5 = new Image();
coinImg5.src = coinSrc5;
const coinImg6 = new Image();
coinImg6.src = coinSrc6;

const trapImg1 = new Image();
trapImg1.src = trapSrc1;
const trapImg2 = new Image();
trapImg2.src = trapSrc2;
const trapImg3 = new Image();
trapImg3.src = trapSrc3;
const trapImg4 = new Image();
trapImg4.src = trapSrc4;


function ConstructorObject(
        id,
        type,
        sprite,
        material, // [bool] Обладает ли физикой
        posX, posY
    ) {

    const resultObject = {
        type: type,
        id: type + id,

        visible: true,
        material: material,

        posX: posX,
        posY: posY,

        eventList: [],

        sprite: null,
        spriteList: [],
        animateSpriteCount: 0,
        animateSpeedCount: 0,
        animateSpeed: 1,

        spriteWidth: 0,
        spriteHeight: 0,

        spriteOffsetX: 0,
        spriteOffsetY: 0
    };

    resultObject.die = function() {
        window.Game.removeObject(this);
    }.bind(resultObject);

    resultObject.staticAnimate = function () {
        if (this.animateSpeedCount === this.animateSpeed) {
            this.animateSpeedCount = 0;

            if (this.animateSpriteCount === this.spriteList.length - 1) {
                this.animateSpriteCount = 0;
            } else {
                this.animateSpriteCount += 1;
            }

            this.sprite = this.spriteList.getSprite(this.animateSpriteCount, this.direction);
        } else {
            this.animateSpeedCount += 1;
        }
    }.bind(resultObject);

    resultObject.moveAnimate = function () {
        if (!this.moves) {
            this.animateSpriteCount = 0;
            this.animateSpeedCount = 0;
            this.sprite = this.spriteList.getStopSprite(this.direction);
            return;
        }

        if (this.animateSpeedCount === this.animateSpeed) {
            this.animateSpeedCount = 0;

            if (this.animateSpriteCount === this.spriteList.length - 1) {
                this.animateSpriteCount = 0;
            } else {
                this.animateSpriteCount += 1;
            }

            this.sprite = this.spriteList.getSprite(this.animateSpriteCount, this.direction);
        } else {
            this.animateSpeedCount += 1;
        }
    }.bind(resultObject);

    if (sprite instanceof SpriteSet) {
        if (sprite.default) {
            resultObject.spriteList = sprite;
            resultObject.sprite = sprite.default[0];
            resultObject.eventList.push(new Event("staticAnimate", resultObject.staticAnimate, false));
        } else {
            resultObject.spriteList = sprite;
            resultObject.sprite = sprite.right[0];
            resultObject.eventList.push(new Event("moveAnimate", resultObject.moveAnimate, false));
        }

    } else if (sprite.length) {
        resultObject.spriteList = sprite;
        resultObject.sprite = sprite[0];
    } else {
        resultObject.sprite = sprite;
    }

    resultObject.addEvent = function(id, func, removable, uniqueness) {
        if (uniqueness) {
            this.eventList = this.eventList.filter(event => event.id !== "event" + id);
        }

        this.eventList.push(new Event(id || this.eventList.length, func, removable));
    }.bind(resultObject);

    resultObject.addEventToStart = function(id, func, removable, uniqueness) {
        if (uniqueness) {
            this.eventList = this.eventList.filter(event => event.id !== "event" + id);
        }

        this.eventList.unshift(new Event(id || this.eventList.length, func, removable));
    }.bind(resultObject);

    resultObject.startEvents = function()  {
        const newEventList = [];

        if (this.eventList.length > 0) {
            this.eventList.forEach(event => {
                event.func();
                if (!event.removable) {
                    newEventList.push(event);
                }
            });

            // this.eventList = newEventList.map((event, id) => {event.id = id; return event} );
            this.eventList = newEventList;
        }
    }.bind(resultObject);


    resultObject.checkClash = function (object, cellSize) {
        if (object.id === this.id) return;

        const halfCell = cellSize/2;

        const selfLeftX = this.posX - halfCell;
        const selfRightX = this.posX + halfCell;
        const selfTopY = this.posY - halfCell;
        const selfBottomY = this.posY + halfCell;

        const objectLeftX = object.posX - halfCell;
        const objectRightX = object.posX + halfCell;
        const objectTopY = object.posY - halfCell;
        const objectBottomY = object.posY + halfCell;

        if (
            selfBottomY > objectTopY &&
            selfTopY < objectBottomY &&
            selfLeftX < objectRightX &&
            selfRightX > objectLeftX
        ) {
            this.clash(object);
            object.clash(this);

            if (this.type === "stone") {
                let changeX;
                let changeY;
                let horizontalSide;
                let verticalSide;
                let absoluteSide;

                if (this.posX < object.posX) {
                    // console.log(`${object.id} справа`);
                    horizontalSide = "right";
                } else if (this.posX > object.posX){
                    // console.log(`${object.id} слева`);
                    horizontalSide = "left";
                } else {
                    // console.log(`${object.id} на одном уровне по горизонтали`);
                    horizontalSide = "one level"
                }

                if (this.posY < object.posY) {
                    // console.log(`${object.id} снизу`);
                    verticalSide = "bottom"
                } else if (this.posY > object.posY) {
                    // console.log(`${object.id} сверху`);
                    verticalSide = "top"
                } else {
                    // console.log(`${object.id} на одном уровне по вертикали`);
                    verticalSide = "one level"
                }

                if (Math.abs(this.posX - object.posX) > Math.abs(this.posY - object.posY)) {
                    absoluteSide = horizontalSide;
                } else {
                    absoluteSide = verticalSide;
                }

                switch (absoluteSide) {
                    case "right":
                        if (object.direction === "left") {
                            object.addEventToStart("stop", object.stopMove, true);
                            object.posX += object.speed;
                        }
                        break;
                    case "left":
                        if (object.direction === "right") {
                            object.addEventToStart("stop", object.stopMove, true);
                            object.posX -= object.speed;
                        }
                        break;
                    case "bottom":
                        if (object.direction === "top") {
                            object.addEventToStart("stop", object.stopMove, true);
                            object.posY += object.speed;
                        }
                        break;
                    case "top":
                        if (object.direction === "bottom") {
                            object.addEventToStart("stop", object.stopMove, true);
                            object.posY -= object.speed;
                        }
                }

            }

            // console.log( `selfLeftX: ${selfLeftX}`);
            // console.log( `selfRightX: ${selfRightX}`);
            // console.log( `selfTopY: ${selfTopY}`);
            // console.log( `selfBottomY: ${selfBottomY}`);
            // console.log( `objectLeftX: ${objectLeftX}`);
            // console.log( `objectRightX: ${objectRightX}`);
            // console.log( `objectTopY: ${objectTopY}`);
            // console.log( `objectBottomY: ${objectBottomY}`);
        }

    }.bind(resultObject);

    resultObject.clash = function (secondObject) {

    }.bind(resultObject);

    return resultObject;
}

function ConstructorAliveObject(id, type, sprite, posX, posY, hp, speed) {
    const resultObject = new ConstructorObject(id, type, sprite,true, posX, posY);

    resultObject.hp = hp || 100;
    resultObject.direction = "top"; // left/right/top/bottom
    resultObject.moves = false;
    resultObject.speed = speed || 1;

    resultObject.spawnPosX = posX;
    resultObject.spawnPosY = posY;

    resultObject.changeDirection = function(direction) {
        if (
            (
                (this.direction === "left" || this.direction === "right") &&
                (direction === "left" || direction === "right")
            ) || (
                (this.direction === "top" || this.direction === "bottom") &&
                (direction === "top" || direction === "bottom")
            )
        ) {
            this.direction = direction;
            const tryChangeEvent = this.eventList.find (event => event.id === "eventtryChangeDirection");
            if (tryChangeEvent) tryChangeEvent.removable = true;
        } else {
            // console.log(findedCell.objects.length > 0 && findedCell.objects[0].type !== "stone");

            this.addEventToStart("tryChangeDirection", function () {
                const foundCell = window.Game.findCell({ object: {posX: resultObject.posX, posY: resultObject.posY}, direction: direction });

                if (
                    resultObject.posX / (40/2) % 2 === 1 &&
                    resultObject.posY / (40/2) % 2 === 1 &&
                    (foundCell && foundCell.objects.length > 0 && foundCell.objects[0].type !== "stone")
                ) {
                    resultObject.direction = direction;
                    this.removable = true;
                }
            }, false, true);
        }
    }.bind(resultObject);

    resultObject.startMove = function() {
        this.moves = true;
    }.bind(resultObject);

    resultObject.stopMove = function() {
        this.moves = false;
    }.bind(resultObject);

    resultObject.move = function() {
        if (this.moves) {
            switch (this.direction) {
                case "left":
                    this.posX -= this.speed;
                    break;
                case "right":
                    this.posX += this.speed;
                    break;
                case "top":
                    this.posY -= this.speed;
                    break;
                case "bottom":
                    this.posY += this.speed;
                    break;
                default:
                    console.log(`Попытка движения в неизвестном направлении: [${this.direction}]`);
            }
        }
    }.bind(resultObject);





    return resultObject;
}

export function ConstructorPlayer(id, posX, posY, nickName, score) {
    const resultObject = new ConstructorAliveObject(
        id,
        "player",
            new SpriteSet({
                left: [player1Img1left, player1Img2left, player1Img3left, player1Img4left, player1Img5left, player1Img6left],
                right: [player1Img1right, player1Img2right, player1Img3right, player1Img4right, player1Img5right, player1Img6right],
                stop: {
                    left: player1ImgStopLeft,
                    right: player1ImgStopRight
                }
            }),
        posX, posY,
        3,
        5
    );

    resultObject.nickName = nickName || "Unamed";
    resultObject.score = score || 0;

    resultObject.eventList.push(new Event("move", resultObject.move, false));

    resultObject.spriteWidth = 49;
    resultObject.spriteHeight = 53;

    resultObject.spriteOffsetX = 0;
    resultObject.spriteOffsetY = -6;

    // resultObject.hp = 3;
    resultObject.killed = false;
    resultObject.rebornTime = 10;
    resultObject.rebornCounter = 0;

    resultObject.reborn = function reborn (deadTime, event) {
        this.rebornCounter = this.rebornTime - (window.Game.getGameTime() - deadTime);
        console.log(`Возрождение через ${this.rebornCounter}`);
        if (this.rebornCounter === 0) {
            console.log("Возродился");

            this.posX = this.spawnPosX;
            this.posY = this.spawnPosY;

            this.killed = false;
            this.material = true;
            this.visible = true;

            event.removable = true;
        }
    };

    resultObject.kill = function kill () {

        this.killed = true;
        this.material = false;
        this.visible = false;
        this.moves = false;

        const deadTime = window.Game.getGameTime();

        if (this.hp > 0) {
            this.hp -= 1;
        }

        if (this.hp > 0) {
            this.rebornCounter = this.rebornTime;
            this.addEventToStart("reborn", function () {resultObject.reborn(deadTime, this)}, false, true);
        }
    }.bind(resultObject);

    resultObject.upScore = function (value) {
        this.score += value;
    }.bind(resultObject);

    resultObject.clash = function (secondObject) {
        if (secondObject.type === "coin") {
            this.upScore(1);
        }
    }.bind(resultObject);

    resultObject.control = function(controlId) {
        if (this.killed) return;

        switch (controlId) {
            case "up":
                this.changeDirection("top");
                this.startMove();
                break;
            case "right":
                this.changeDirection("right");
                this.startMove();
                break;
            case "down":
                this.changeDirection("bottom");
                this.startMove();
                break;
            case "left":
                this.changeDirection("left");
                this.startMove();
                break;
            case "stop":
                this.stopMove();
                break;
        }
    }.bind(resultObject);

    return resultObject;
}

export function ConstructorStone(id, posX, posY)  {
    const resultObject = new ConstructorObject(id, "stone", stone_isolatedImg, true, posX, posY);

    resultObject.spriteWidth = 40;
    resultObject.spriteHeight = 52;

    resultObject.spriteOffsetY = -6;

    resultObject.stoneSprites = {
        isolated: stone_isolatedImg,
        connectedLeft: stone_connectedLeftImg,
        connectedRight: stone_connectedRightImg,
        connectedTop: stone_connectedTopImg,
        connectedBottom: stone_connectedBottomImg,
        betweenHorizontal: stone_betweenHorizontalImg,
        betweenVertical: stone_betweenVerticalImg,
        connectedBottomAndRight: stone_connectedBottomAndRightImg,
        connectedBottomAndLeft: stone_connectedBottomAndLeftImg,
        connectedTopAndLeft: stone_connectedTopAndLeftImg,
        connectedTopAndRight: stone_connectedTopAndRightImg,
        connectedAll: stone_connectedAllImg,
        betweenVerticalConnectedRight: stone_betweenVertical_connectedRightImg,
        betweenVerticalConnectedLeft: stone_betweenVertical_connectedLeftImg,
        betweenHorizontalConnectedBottom: stone_betweenHorizontal_connectedBottomImg,
        betweenHorizontalConnectedTop: stone_betweenHorizontal_connectedTopImg,
    };


    /**
     *
     * mode:
     * isolated
     * connectedLeft, connectedRight, connectedTop, connectedBottom,
     * betweenHorizontal, betweenVertical,
     * connectedBottomAndRight, connectedBottomAndLeft, connectedTopAndLeft, connectedTopAndRight,
     * connectedAll
     * betweenVerticalConnectedRight, betweenVerticalConnectedLeft,
     * betweenHorizontalConnectedBottom, betweenHorizontalConnectedTop,
     *
     */
    resultObject.setSprite = function setSprite(mode) {
        if (this.stoneSprites[mode]) {
            this.sprite = this.stoneSprites[mode];
        } else {
            console.log("Попытка установки неизвестного типа спрайта для стены: " + mode);
        }
    }.bind(resultObject);

    return resultObject;
}

export function ConstructorCoin(id, posX, posY ) {
    const resultObject = new ConstructorObject(
        id,
        "coin",
        new SpriteSet([coinImg1, coinImg2, coinImg3, coinImg4, coinImg5, coinImg6]),
        true,
        posX, posY);

    resultObject.spriteWidth = 25;
    resultObject.spriteHeight = 28;

    resultObject.spriteOffsetY = -15;

    resultObject.animateSpeed = 2;

    resultObject.clash = function (secondObject) {
        if (secondObject.type === "player") {

            const soundCoin = new Audio();
            soundCoin.src = soundCoinSrc;
            soundCoin.volume = 0.005;
            // soundCoin.autoplay = true;
            soundCoin.play();
            this.die();
        }
    }.bind(resultObject);

    return resultObject;
}

export function ConstructorTrap(id, posX, posY, frameDuration) {
    const resultObject = new ConstructorObject(
        id,
        "trap",
        new SpriteSet([trapImg1, trapImg2, trapImg3, trapImg4, trapImg3, trapImg2]),
        true,
        posX, posY
    );

    resultObject.active = false;
    resultObject.animateSpeed = 1;

    resultObject.staticAnimate = function () {
        resultObject.active = this.animateSpriteCount === 3 || this.animateSpriteCount === 2;

        if (this.animateSpriteCount === 0 || this.animateSpriteCount === 3) {
            if (this.animateSpeedCount === this.animateSpeed * frameDuration) {
                this.animateSpriteCount += 1;
                this.animateSpeedCount = 0;
            } else {
                this.animateSpeedCount += 1;

            }
        } else {
            if (this.animateSpeedCount === this.animateSpeed) {
                this.animateSpeedCount = 0;

                if (this.animateSpriteCount === this.spriteList.length - 1) {
                    this.animateSpriteCount = 0;
                } else {
                    this.animateSpriteCount += 1;
                }

                this.sprite = this.spriteList.getSprite(this.animateSpriteCount, this.direction);
            } else {
                this.animateSpeedCount += 1;
            }
        }
    }.bind(resultObject);

    resultObject.addEvent("staticAnimate", resultObject.staticAnimate, false, true);

    resultObject.clash = function (secondObject) {
        if (this.active && secondObject.type === "player") {
            // console.log("Player убит");
            secondObject.kill();
        }
    }.bind(resultObject);

    return resultObject;
}

export class Cell {
    constructor(id, posX, posY, fieldPosRow, fieldPosColumn) {
        this.id = "cell" + id;
        this.posX = posX;
        this.posY = posY;
        this.objects = [];
        this.sprite = cellImg;
        this.visible = true;

        this.fieldPosRow = fieldPosRow;
        this.fieldPosColumn = fieldPosColumn;
    }

    set(object) {
        this.objects.push(object);

        object.posX = this.posX;
        object.posY = this.posY;

        if (object.type === "player") {
            object.spawnPosX = this.posX;
            object.spawnPosY = this.posY;
        }
    }

    clear(withDie) {
        if (withDie) {
            this.objects.forEach(object => {
                object.die();
            });
        }
        this.objects = [];
    }
}

/**
 * Важно правильно использовать связывание this
 * Если функция стрелочноя, то this ссылается на КОНТЕКСТНЫЙ объект
 * Если функция function(), то this ссылается на объект Event
 */
class Event {
    constructor(id, func, removable) {
        this.id = "event" + id;
        this. func = func;
        this.removable = removable === undefined? true : removable;
    }
}

class SpriteSet {
    constructor(spriteList) {
        if (spriteList.length) {
            this.default = spriteList;
            this.length = spriteList.length;
        } else {
            this.right = spriteList.right;
            this.left = spriteList.left;
            if (spriteList.stop) {
                this.stop = {
                    right: spriteList.stop.right,
                    left: spriteList.stop.left
                }
            }

            this.length = spriteList.left.length;
        }

        this.lastDirection = "right";
    }

    getStopSprite(direction) {
        if (direction === "right") {
            this.lastDirection = direction;
            return this.stop.right;
        } else if (direction === "left") {
            this.lastDirection = direction;
            return this.stop.left;
        } else {
            return this.getStopSprite(this.lastDirection);
        }
    }

    getSprite(count, direction) {
        if (direction) {
            if (direction === "right") {
                this.lastDirection = direction;
                return this.right[count];
            } else if (direction === "left") {
                this.lastDirection = direction;
                return this.left[count];
            } else {
                return this.getSprite(count, this.lastDirection)
            }
        } else {
            return this.default[count];
        }
    }
}

export class Map {
    constructor(stoneList, traps, playersFieldCoords, mobSpawnPoints, holesInBaseStones) {
        this.stoneList = stoneList;
        this.traps = traps;
        this.playersFieldCoords = playersFieldCoords;
        this.mobSpawnPoints = mobSpawnPoints;
        this.holesInBaseStones = holesInBaseStones;
    }
}

